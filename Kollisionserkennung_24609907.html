<!DOCTYPE html>
<html>
    <head>
        <title>PRG Ming  : Kollisionserkennung</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">PRG Ming </a></span>
                            </li>
                                                    <li>
                                <span><a href="24609398.html">PRG Ming √úbersicht</a></span>
                            </li>
                                                    <li>
                                <span><a href="Sprint-3_24609610.html">Sprint 3</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            PRG Ming  : Kollisionserkennung
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
    
        
    
        
        
            Created by <span class='author'> Unbekannter Benutzer (jacqueline.dittrich@fh-kiel.de)</span>, last modified by <span class='editor'> Jacqueline R√§hse</span> on Sep 23, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>Wenn wir Programme schreiben, dann sollen Nutzer in der Regel mit diesen Programmen interagieren k√∂nnen. Eine kleine Einf√ºhrung in Interaktion hatten wir bereits in vorherigen Sprints. Nun wollen wir weiter in das Thema einsteigen:</p><p>Das einfachste interaktive Element ist eine Form, die &quot;aktiv&quot; wird, sobald der Mauszeiger auf ihr liegt, und &quot;inaktiv&quot;, sobald der Mauszeiger wieder fort ist. Dazu m√ºssen wir zun√§chst wissen, wie wir feststellen, dass der Mauszeiger auf einem Objekt liegt. Das nennt man auch <strong>Kollisionerkennung</strong> und ist in <strong>Computerspielen</strong> von hoher Bedeutung.</p><h1 id="Kollisionserkennung-Rechteck">Rechteck</h1><p>Kollisionserkennung zwischen einem Punkt (Mauszeiger) und eine Rechteck, das parallel zu den Achsen des Koordinatensystems liegt, ist sehr einfach. Wenn der Punkt (<code>x</code>, <code>y</code>) ist und das rechteck √ºber <code>rx</code>, <code>ry</code>, <code>rwidth</code>, <code>rheight</code> definiert ist, dann liegt eine Kollision vor, wenn die folgenden zwei Bedingungen gelten (bei <code>rectMode(CORNER)</code>) :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">rx &lt;= x &amp;&amp; x &lt;= rx + rwidth // Ausformuliert: x liegt zwischen rx und rwidth  
ry &lt;= y &amp;&amp; y &lt;= ry + rheight // Ausformuliert: y liegt zwischen ry und rheight</pre>
</div></div><p>Im Code sieht das so aus (statt <code>x</code>, <code>y</code> findest du <code>mouseX</code>, <code>mouseY</code>):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">// interface_1
// Kollision mit Rechteck (Selektion per Rollover)

int rx = 50;
int ry = 50;
int rwidth = 150; // Breite
int rheight = 200; // H√∂he

void setup() {
  size(300, 300);
  noStroke(); // Das bedeutet: Das Rechteck hat keinen Rand
}

void draw() {

  // setze F√ºllfarbe ...
  if (rx &lt;= mouseX &amp;&amp; 
      ry &lt;= mouseY &amp;&amp; 
      mouseX &lt;= rx + rwidth &amp;&amp;
      mouseY &lt;= ry + rheight) {
    // ... wenn Mauszeiger im Rechteck =&gt; rot
    fill(255, 0, 0);
  }
  else {
    // ... sonst: wei√ü
    fill(255);
  }
  rect(rx, ry, rwidth, rheight);
}</pre>
</div></div><p><br/></p><p>Kopiere diesen Code in Processing und du wirst sehen: Das Rechteck wird rot, sobald du mit der Maus dr√ºber f√§hrst.<em><br/></em></p><p><br/></p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p><strong>Tip: </strong>Sieh dir an, wie die Bedingung in des if-Anweisung geschrieben wurde. Was f√§llt dir auf? Richtig: Hinter dem <code>&amp;&amp;</code> beginnt immer eine neue Zeile. Das ist eine <em>Codestyle Konvention</em>, die deinen Code √ºbersichtlicher macht. Die Konvention lautet:</p><p><em>¬†¬†¬†¬† Wenn eine Bedingung aus mehreren booleschen Ausdr√ºcken besteht, dann wir mit jedem Logik-Operator eine neu Zeile begonnen.</em></p></div></div><p><br/></p><h1 id="Kollisionserkennung-Kreis">Kreis</h1><p>Kollisionserkennung zwischen einem Punkt und einem <strong>Kreis</strong> ist sogar<em> noch einfacher.</em> Dazu vergleicht man die Distanz des Punkts (<code>x</code>, <code>y</code>) mit dem Mittelpunkt (<code>cx</code>, <code>cy</code>) des Kreises. Ist die Distanz geringer als der Radius, so ist der Punkt im Kreis:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">dist(x, y, cx, cy) &lt; radius</pre>
</div></div><p>Die Funktion <code>dist()</code> berechnet den Abstand zweier Punkte. Im folgenden Code nehmen wieder <code>mouseX</code>, <code>mouseY</code> den Platz von <code>x</code>, <code>y</code> ein und der Radius errechnet sich aus <code>diameter/2</code>.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">// interface_2
// Kollision mit Kreis (Selektion per Rollover)

int cx = 170;
int cy = 160;
int diameter = 180; // Durchmesser

void setup() {
  size(300, 300);
  noStroke();
}

void draw() {
  // setze F√ºllfarbe ...
  if (dist(mouseX, mouseY, cx, cy) &lt; diameter/2) {
    // ... wenn Mauszeiger im Rechteck =&gt; rot
    fill(255, 0, 0);
  }
  else {
    // ... sonst: wei√ü
    fill(255);
  }
  ellipse(cx, cy, diameter, diameter);
}</pre>
</div></div><p><br/></p><p><em><br/></em></p><div class="confluence-information-macro has-no-icon confluence-information-macro-note"><div class="confluence-information-macro-body"><h1 id="Kollisionserkennung-√úbungsaufgaben">√úbungsaufgaben</h1><h4 id="Kollisionserkennung-Farb-Buttons">Farb-Buttons</h4><p>Erstelle drei wei√üe Buttons mit den Beschriftungen &quot;Rot&quot;, &quot;Gr√ºn&quot; und &quot;Blau&quot;.</p><ul><li>Solange der Mauszeiger √ºber einem der Buttons schwebt, soll der entsprechende Button hellgrau sein.</li><li>Wenn der User auf einen der Buttons klickt, soll der Hintergrund die entsprechende Farbe annehmen.</li><li>Wenn der User au√üerhalb der Buttons auf den Hintergrund klickt, wird dieser wieder grau.</li></ul><h4 id="Kollisionserkennung-√úberlappendeButtons">√úberlappende Buttons</h4><p>Du hast zwei Quadrate mit Seitenl√§nge 50px. F√§rbe den &quot;Mauszeiger&quot; (Kreis) farbig ein, sobald er innerhalb der Bereiche ist. Konkret: <strong>rot</strong> im ersten Quadrat, <strong>gr√ºn</strong> im zweiten Quadrat und <strong>blau</strong> in der Schnittmenge.</p><p>Verwende den Basiscode und versuche, den Code so zu schreiben, dass das Programm auch funktioniert, wenn man die Werte von x1, y1, x2, y2 √§ndert.</p><p>Basiscode:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">int x1 = 30;
int y1 = 10;
int x2 = 10;
int y2 = 40;

void draw() {
  background(255);
  noFill();
  rect(x1, y1, 50, 50);
  rect(x2, y2, 50, 50);

  ellipse(mouseX, mouseY, 20, 20);
}</pre>
</div></div><h4 id="Kollisionserkennung-KollisionPunkt-Linie">Kollision Punkt-Linie</h4><p>Gegeben sind ein Punkt <strong>a</strong> und eine Linie <strong>b</strong>. Die Linie kannst du mit den Pfeiltasten bewegen. Erg√§nze den Basiscode unten so, dass immer sich die Linie unterhalt des Punkts (also nicht links oder rechts davon) befindet, die Linie rot gef√§rbt erscheint.</p><p>Hier ist der Basiscode. Fokussiere dich ganz bewusst auf die x-Werte.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">float ax = 50; // x-Position von Punkt a

float bx = 5; // x-Position des Startpunkts der Linie b
float bwidth = 30; // Breite der Linie b

void draw() {
  background(0);
  strokeWeight(5);

  stroke(0,255,0);
  point(ax, 50);

  stroke(255);

  // HIER DEINCODE

  line(bx, 60, bx+bwidth, 60);

  if (keyPressed) {
    if (keyCode == LEFT) {
      bx -= 2;
    } else if (keyCode == RIGHT) {
      bx += 2;
    }
  }
}</pre>
</div></div><h4 id="Kollisionserkennung-KollisionLinie-Linie">Kollision Linie-Linie</h4><p>Wir erweitern das Szenario aus der letzten Aufgabe so, dass <strong>a</strong> jetzt auch eine Linie ist. Wie musst du den Code erweitern, damit die untere Linie <strong>b</strong> immer dann rot wird, w√§hrend sich die beiden Linien <strong>√ºberschneiden</strong>?</p><p>Und wieder Basiscode:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">float ax = 60; // x-Position des Startpunkts der Linie a
float awidth = 30; // Breite der Linie a

float bx = 5; // x-Position des Startpunkts der Linie b
float bwidth = 40; // Breite der Linie b

void setup() {
  size(150, 100);
}

void draw() {
  background(0);
  strokeWeight(4);

  stroke(0,255,0);
  line(ax, 50, ax+awidth, 50);

  stroke(255);

  // HIER DEIN CODE

  line(bx, 60, bx+bwidth, 60);

  if (keyPressed) {
    if (keyCode == LEFT) {
      bx -= 2;
    } else if (keyCode == RIGHT) {
      bx += 2;
    }
  }
}</pre>
</div></div></div></div><h1 id="Kollisionserkennung-Mini-GameChallenge"><br/>Mini-Game Challenge</h1><p>Hier siehst du zwei Programmieraufgaben f√ºr Mini-Games. Beides Aufgaben sind etwas aufw√§ndiger als die normalen √úbungsaufgaben, aber eben auch sehr lehrreich, da du hier viele Programmierfertigkeiten √ºben und einbinden kannst. Und am Ende kommt ein richtiges kleines Mini-Game raus. Nutze diese Challenge zum √ºben - was du hier lernst, kannst du ebenso in eurem Projekt anwenden.</p><h2 id="Kollisionserkennung-Pongüèì">Pong üèì</h2><p>Programmiere den Spiele-Klassiker Pong als Ein-Spieler-Version.</p><ul><li>Zun√§chst soll auf dem Bildschirm &quot;PRESS SPACE&quot; stehen. Sobald der Spieler die Leertaste dr√ºckt, geht das Spiel los und der Text verschwindet.</li><li>Der &quot;Schl√§ger&quot; des Spielers soll am unteren Bildschirmrand sein. Der Ball prallt links, rechts und oben ab. Wenn der Ball den unteren Rand ber√ºhrt und dem Spieler sozusagen &quot;entwischt&quot;,¬† ist das Spiel zu Ende und es wird wieder &quot;PRESS SPACE&quot; angezeigt.</li></ul><p><strong>Tipps:</strong> Um die Kollision zwischen &quot;Ball&quot; und dem Balken zu berechnen, helfen dir vielleicht die zwei vorigen Aufgaben. Um den Zustand &quot;Game Over&quot; vom eigentlichen Spiel zu trennen, verwendest du eine boolesche Variable <code>gameOver</code>, die anfangs <code>false</code> ist. In draw() packst dann gleich zu Beginn ein <code>if (gameOver) ...</code>, wo entweder der Schriftzug &quot;Press SPACE&quot; gezeigt wird oder (im Else-Teil) das Spiel verarbeitet wird.</p><h2 id="Kollisionserkennung-RaincatcherüåßÔ∏è‚òî">Raincatcher <span class="emoji">üåßÔ∏è‚òî</span></h2><p>Wir schreiben das Spiel &quot;Raincatcher&quot;. Es geht darum, einen Eimer zu steuern, der Regentropfen einf√§ngt.</p><p>Achte darauf, deine Variablen &quot;gut&quot; zu benennen, damit du im weiteren Verlauf nicht den √úberblick verlierst. Also besser <code>eimerX</code> statt <code>ex</code> oder <code>x</code>.</p><h3 id="Kollisionserkennung-Eimer">Eimer</h3><p>Programmiere einen &quot;Eimer&quot;, den du mit den Cursortasten (links/rechts) steuern kannst. Achte darauf, dass der Eimer fl√ºssig nach links und rechts f√§hrt, und dass er nie die Grenzen des Bildschirms verl√§sst.</p><h3 id="Kollisionserkennung-Tropfen">Tropfen</h3><p>Programmiere die Tropfen: Drei Tropfen (oder andere Gegenst√§nde) fliegen von oben nach unten. Der x- und y-Startpunkt sind beide zuf√§llig zu Beginn (verwende die Funktion <code>random()</code> von Processing). Sobald ein Tropfen den Boden erreicht, verschwindet er und ein &quot;neuer&quot; Tropfen erscheint an zuf√§lliger Position am oberen Rand, mit einer zuf√§lligen neuen Farbe. Vermeide es, dass Tropfen am Rand &quot;angeschnitten&quot; erscheinen.</p><p><strong>Tipp:</strong> Beginne mit einem einzigen Tropfen.</p><h3 id="Kollisionserkennung-Tropfenfangen">Tropfen fangen<em><br/></em></h3><p>Jetzt kannst du deine Regentropfen einsammeln! Z√§hle einen Punkt hoch, wenn du einen Tropfen f√§ngst. Z√§hle ein &quot;Leben&quot; runter, wenn dir ein Tropfen entwischt. Beginne evtl. nur mit einem Tropfen. Das Programm wird bereits recht umfangreich. Achte also auf gute Kommentierung und gute Benennung deiner Variablen.</p><p><br/></p>
                    </div>

                                        
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 17, 2022 11:20</p>
                    <div id="footer-logo"><a href="https://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
