<!DOCTYPE html>
<html>
    <head>
        <title>PRG Ming  : Primitive Datentypen &amp; Objekttypen</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">PRG Ming </a></span>
                            </li>
                                                    <li>
                                <span><a href="24609398.html">PRG Ming Übersicht</a></span>
                            </li>
                                                    <li>
                                <span><a href="Sprint-3_24609610.html">Sprint 3</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            PRG Ming  : Primitive Datentypen &amp; Objekttypen
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
    
        
    
        
        
            Created by <span class='author'> Unbekannter Benutzer (jacqueline.dittrich@fh-kiel.de)</span>, last modified by <span class='editor'> Jacqueline Rähse</span> on Sep 24, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>Bisher haben wir mit den uns bekannten Datentypen einfach nur gearbeitet, ohne uns groß Gedanken über die kleinen aber feinen Unterschiede zu machen.</p><ul style="list-style-type: square;"><li>Warum werden manche Datentypen klein geschrieben und andere groß geschrieben? →  <code>int, float, char, boolean,</code> ... <strong>VS.</strong> <code>String, PVector, SoundFile,</code> ...</li><li>Warum benötigt man für die Wertezuweisung bei manchen Datentypen das Schlüsselwort <code>new </code>und bei anderen nicht? → <code> int foo = 5;</code> <strong>VS.</strong><code><strong> </strong>int[] bar = new int[10]; </code></li><li>Warum haben manche Datentypen einen &quot;richtigen&quot; Standardwert (z.B. 0 oder false) und andere den Standardwert <code>null</code>?</li></ul><p>All das ist darauf zurückzuführen, dass sie alle Datentypen einteilen lassen in primitive Datentypen und Objekttypen. Dies sorgt dann unter anderem für die oben genannten Unterschiede. Schauen wir uns beide Typen einmal genauer an.</p><h1 id="PrimitiveDatentypen&amp;Objekttypen-PrimitiveDatentypen">Primitive Datentypen</h1><p>In Java gibt gibt es <strong>acht primitive Datentypen</strong>, alle anderen Datentypen werden<strong> </strong>Objekte bzw. Objekttypen genannt.  Das sind die acht primitiven Datentypen (ein paar davon kennst du bereits):</p><p style="text-align: center;">byte, short, integer, long, float, double, char, boolean</p><h2 id="PrimitiveDatentypen&amp;Objekttypen-Merkmale">Merkmale</h2><p>Primitive Datentypen zeichnen sich dadurch aus, dass sie einfach <strong>nur Werte speichern</strong>. Deswegen haben sie auch einen &quot;richtigen&quot; <strong>Standardwert </strong>und benötigen nicht das Schlüsselwort <code>new </code>bei der Initialisierung. Außerdem werden primitive Datentypen <strong>klein geschrieben</strong>. Daran kann man schnell erkennen, dass es sich um einen primitiven Datentyp handelt.</p><h2 id="PrimitiveDatentypen&amp;Objekttypen-Einteilung">Einteilung</h2><p>Die primitiven Datentypen sind in Gruppen eingeteilt. Zahlen sind in Java so wichtig, dass sechs der acht primitiven Datentypen numerisch sind. Das bedeutet, dass jeder von diesen, bis auf den <code>char</code> und den <code>boolean</code>, Zahlenwerte speichert. Numerische primitive Datentypen lassen sich in <strong>ganzzahlige Typen</strong> und <strong>Gleitpunkttypen</strong> unterteilen. <code>byte</code>, <code>short</code>, <code>integer</code> und <code>long</code> bilden somit die <strong>ganzzahligen</strong> <strong>Typen</strong> und <code>float</code> und <code>double</code> die <strong>Gleitpunkttypen.</strong></p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/><col/></colgroup><tbody><tr><td class="highlight-grey confluenceTd" style="text-align: center;" title="Hintergrundfarbe : Grau" colspan="2" data-highlight-colour="grey"><strong>Numerische Datentypen</strong></td><td class="highlight-grey confluenceTd" style="text-align: center;" title="Hintergrundfarbe : Grau" data-highlight-colour="grey"><br/></td></tr><tr><td class="highlight-grey confluenceTd" style="text-align: center;" title="Hintergrundfarbe : Grau" data-highlight-colour="grey"><strong>Ganzzahlige Typen</strong></td><td class="highlight-grey confluenceTd" style="text-align: center;" title="Hintergrundfarbe : Grau" data-highlight-colour="grey"><strong>Gleitkommatypen</strong></td><td class="highlight-grey confluenceTd" style="text-align: center;" title="Hintergrundfarbe : Grau" data-highlight-colour="grey"><br/></td></tr><tr><td class="confluenceTd">byte, short, integer, long</td><td class="confluenceTd">float, double</td><td class="confluenceTd">booelan, char</td></tr></tbody></table></div><p><br/></p><p>Warum gibt es denn so viele verschiedenen numerische Datentypen? 1-3 würden doch eigentlich reichen. Der Grund hierfür ist wieviel <strong>Platz</strong> sie im <strong>Speicher</strong> einnehmen. Jeder dieser Typen besitzt eine feste Zahl an Bit, die zum Speichern des Werts im Speicher verwendet werden, der sogenannte <strong>Speicherverbrauch</strong>. Mehr Bit bedeutet mehr Platz im Speicher, was wiederum für entweder größere Werte oder eine höhere Genauigkeit sorgt.</p><h2 id="PrimitiveDatentypen&amp;Objekttypen-Speicherverbrauch">Speicherverbrauch</h2><h3 id="PrimitiveDatentypen&amp;Objekttypen-longundbyte">long und byte</h3><p>Wenn man einem numerischen Datentyp eine kleine Zahl zuweisen möchte, dann wäre es reine <strong>Speicherverschwendung</strong> den <code>long </code>Datentyp zu verwenden, der eine Größe von <strong>64 Bit </strong>hat<strong>.</strong> Mithilfe von <code>long </code>kann man deswegen ganze Zahlen im Bereich von -2<sup>63</sup> bis 2<sup>63</sup>-1 darstellen. Für kleine Zahlen, wie z.B. 34, ist der Datentyp <code>byte </code>vollkommen ausreichend. <code>byte </code>hat eine Größe von 8 Bit und einen Wertebereich von -128 bis +127.</p><p>Um Speicher zu sparen ist es wichtig zu wissen, welchen Datentyp man verwenden sollte. Bei kleinen Programmen macht das kaum einen Unterschied. Solltest du aber mal an einem größeren Projekt arbeiten, ist es sehr wichtig, wie du mit diesen Datentypen umgehst. Der geläufigste ganzzahlige primitive Datentyp ist dabei der <code>int</code>, da er einen angemessenen Wertebereich mit 32 Bit besitzt.</p><h3 id="PrimitiveDatentypen&amp;Objekttypen-doubleundfloat">double und float</h3><p>Wenn ich einem Datentyp eine Gleitkommazahl zuweisen möchte, dann muss ich den Datentyp float oder double verwenden. Der Unterschied der beiden Typen ist deren Größe. Somit ist <code>double </code><strong>mit 64 Bit doppelt</strong> so groß wie <code>float </code>mit <strong>32 Bit</strong> und besitzt daher einen viel <strong>größeren Wertebereich</strong>. So wird <code>float </code>oftmals als ein Gleitpunkttyp mit „<em>einfacher </em>Genauigkeit“ bezeichnet, während <code>double </code>Gleitpunkttyp mit „<em>doppelter </em>Genauigkeit“ genannt wird. Versucht man diese Gleitpunkttypen zu vermischen, kann es zu Datenverlust führen.</p><p>Wenn du explizit ein <code>float</code>-Literal, also eine Zeichenfolge die einen <code>float</code>-Wert darstellt, anfordern möchtest, musst du am Ende der Kommazahl ein großes oder kleines „f“ schreiben. Das gleiche gilt auch für ein <code>double</code>-Literal, indem du ein großes oder kleines „d“ am Ende setzt.</p><h2 id="PrimitiveDatentypen&amp;Objekttypen-Übersicht">Übersicht</h2><p>In dieser Übersicht kannst du sehen, welchen Wertebereich, Speicherverbrauch und Standardwerte die einzelnen Datentypen haben (Wenn du eine Variable nur deklarierst, aber nicht initialisierst, dann bekommt sie einen Standardwert).</p><div class="table-wrap"><table class="wrapped relative-table confluenceTable" style="text-align: left;width: 85.299%;"><colgroup><col style="width: 6.30631%;"/><col style="width: 14.4144%;"/><col style="width: 18.4685%;"/><col style="width: 13.8996%;"/><col style="width: 46.9112%;"/></colgroup><tbody><tr><th class="confluenceTh">Typname</th><th class="confluenceTh">Größe (Speicherverbrauch)</th><th class="confluenceTh">Wertebereich</th><th colspan="1" class="confluenceTh">Standardwert</th><th class="confluenceTh">Beschreibung</th></tr><tr><td class="confluenceTd">boolean</td><td class="confluenceTd">8 bit</td><td class="confluenceTd">true / false</td><td colspan="1" class="confluenceTd">false</td><td class="confluenceTd">Boolescher Wahrheitswert, Boolescher Typ</td></tr><tr><td class="confluenceTd">char</td><td class="confluenceTd">16 bit</td><td class="confluenceTd">0 ... 65.535 (z. B. 'A')<br/><br/></td><td colspan="1" class="confluenceTd"><span class="ILfuVd"><span class="hgKElc"><code>\u0000</code> (= Zeichen für <code>null</code> )<br/></span></span></td><td class="confluenceTd">Unicode-Zeichen (UTF-16)</td></tr><tr><td class="confluenceTd">byte</td><td class="confluenceTd">8 bit</td><td class="confluenceTd">-128 ... 127</td><td colspan="1" class="confluenceTd">0</td><td class="confluenceTd">Zweierkomplement-Wert</td></tr><tr><td class="confluenceTd">short</td><td class="confluenceTd">16 bit</td><td class="confluenceTd">-32.768 ... 32.767</td><td colspan="1" class="confluenceTd">0</td><td class="confluenceTd">Zweierkomplement-Wert</td></tr><tr><td class="confluenceTd">int</td><td class="confluenceTd">32 bit</td><td class="confluenceTd">-2.147.483.648 ... 2.147.483.647</td><td colspan="1" class="confluenceTd">0</td><td class="confluenceTd">Zweierkomplement-Wert</td></tr><tr><td class="confluenceTd">long</td><td class="confluenceTd">64 bit</td><td class="confluenceTd">-2<sup>63</sup> bis 2<sup>63</sup>-1</td><td colspan="1" class="confluenceTd">0L</td><td class="confluenceTd">Zweierkomplement-Wert</td></tr><tr><td class="confluenceTd">float</td><td class="confluenceTd">32 bit</td><td class="confluenceTd">-3.40282347 *10<sup>38</sup> bis 3.40282347 *10<sup>38</sup></td><td colspan="1" class="confluenceTd">0.0f</td><td class="confluenceTd">32-bit IEEE 754 (<em>es wird nicht empfohlen, dies für Programme zu verwenden, die sehr genau rechnen müssen)</em></td></tr><tr><td class="confluenceTd">double</td><td class="confluenceTd">64 bit</td><td class="confluenceTd">-1.79769313486231570 *10<sup>308</sup> bis 1.79769313486231570 *10<sup>308</sup></td><td colspan="1" class="confluenceTd">0.0d</td><td class="confluenceTd">64-bit IEEE 754, doppelte Genauigkeit</td></tr></tbody></table></div><h1 id="PrimitiveDatentypen&amp;Objekttypen-Objekttypen">Objekttypen</h1><p>Anders als die primitiven Datentypen, die nur Werte speichern können, können Objekttypen ganze Objekte speichern - aber was ist so ein Objekt? Ein Objekt kannst du dir bildlich vorstellen, wie einen Gegenstand, zum Beispiel eine Mikrowelle. Eine Mirkowelle hat einen Namen, eine Höhe, Länge und Breite, ein paar Funktionen (an, aus, öffnen, schließen, ...). All das steckt in dem Gegenstand mit dem Typ Mikrowelle. Wenn ich jetzt versuchen würde diese Mikrowelle in Programmcode darzustellen, dann könnte das so aussehen:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: true; theme: Confluence" data-theme="Confluence">MicroWave meineMikrowelle = new MicroWave(&quot;Heatmaster 3000&quot;);  // Erstellen einer neuen Mikrowelle mit dem Namen &quot;Heatmaster 3000&quot;

// Funktionen der Mikrowelle ausführen
meineMikrowelle.open();   
meinMikrowelle.insertFood();  
meineMikrowelle.close();  
meineMikrowelle.setTimer(120);
meineMikrowelle.start();

println(meineMikrowelle.height);  // Höhe der Mikrowelle in der Konsole ausgeben</pre>
</div></div><p><br/></p><p>Hier an diesem fiktiven Beispiel können wir ein paar wichtige Eigenschaften von Objekttypen sehen:</p><ul style="list-style-type: square;"><li>Objekttypen werden <strong>groß geschrieben</strong>, damit man sie als solche erkennt. Hier lautet der Datentyp für mein Mikrowelle <code>MicroWave</code>.</li><li>Objekttypen werden in der Regel<strong> mit dem Schlüsselwort <code>new </code>initialisiert.</strong> Hier gibt es nur wenige Ausnahmen, bei denen man <em>sowohl </em><code>new </code>verwenden kann als <em>auch </em>eine andere, &quot;einfache&quot; Schreibweise.Es geht also beides. Das ist zum Beispiel bei <code>String </code>oder bei Arrays der Fall.</li><li>Objekttypen haben <strong>Funktionen und Felder, </strong>auf die mithilfe der Punktnotation zugegriffen werden kann. Funktionen werden (wie gewöhliche Funktionen auch) mit Klammern geschrieben, z.B. <code>.open()</code>. Felder hingegen sind einfach nur Variablen und werden somit ohne Klammer geschrieben, z.B. <code>name</code>.</li></ul><p>Objekte sind also deutlich komplexere Konstruktionen, als Werte. Aus diesem Grund haben Objekte auch den <strong>Standardwert </strong><code>null</code>, also &quot;nichts&quot;.</p><p>Wir haben schon einige Objekttypen kennengelernt und zwar Arrays,<code> String, SoundFile</code> und <code>PVector</code>. Im nächsten Sprint werden wir uns mehr mit der Verarbeitung von Strings beschäftigen und einige der Funktionen von <code>String </code>kennenlernen.</p><p><br/></p><div class="confluence-information-macro has-no-icon confluence-information-macro-tip"><div class="confluence-information-macro-body"><h1 id="PrimitiveDatentypen&amp;Objekttypen-Zusammenfassung">Zusammenfassung</h1><p>In Java gibt es primitive Datentypen und Objekttypen.</p><ul style="list-style-type: square;"><li><strong>Die acht primitiven Datentypen</strong> sind byte, short, integer, long, float, double, char, boolean<br/><ul style="list-style-type: square;"><li>Sie speichern einfache Werte</li><li>Die numerischen primitiven Datentypen werden unterteilt ist ganzzahlige Typen und Gleitkommatypen</li><li>Die numerischen primitiven Datentypen haben unterschiedliche Größen und Wertebereiche</li><li>Primitive Datentypen werden klein geschrieben</li></ul></li><li><strong>Objekttypen </strong>speichern Objekte<ul style="list-style-type: square;"><li>Objekte bestehen aus <strong>Funktionen </strong>und <strong>Feldern</strong>, auf die mittels <strong>Punktnotation </strong>zugegriffen werden kann.</li><li>Objekttypen werden groß geschrieben und in der Regel mit dem Schlüsselwort new initialisiert.</li><li>Objekttypen haben den Standardwert null.</li><li>Uns bekannte Objekttypen sind:<code> </code>Arrays, <code>String, SoundFile</code> und <code>PVector</code>.</li></ul></li></ul></div></div><p><br/></p>
                    </div>

                                        
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 17, 2022 11:20</p>
                    <div id="footer-logo"><a href="https://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
